import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';

// ===================== TYPES =====================
export interface CodeEditorProps {
  /** The text content of the editor */
  value: string;
  /** Callback when text changes */
  onChange?: (value: string) => void;
  /** Whether the editor is read-only */
  readOnly?: boolean;
  /** Font size in px */
  fontSize?: number;
  /** Language for syntax highlighting */
  language?: 'ini' | 'plain';
  /** Placeholder text when empty */
  placeholder?: string;
  /** Whether to show line numbers */
  showLineNumbers?: boolean;
  /** Whether to highlight the active line */
  highlightActiveLine?: boolean;
  /** Line number to highlight (1-based) */
  highlightLine?: number | null;
  /** Whether to show minimap indicator */
  showMinimap?: boolean;
  /** Tab size (number of spaces) */
  tabSize?: number;
  /** Whether to wrap long lines */
  wordWrap?: boolean;
  /** Max height (CSS value), default 100% */
  maxHeight?: string;
  /** Min height (CSS value) */
  minHeight?: string;
  /** Custom class */
  className?: string;
  /** On focus */
  onFocus?: () => void;
  /** On blur */
  onBlur?: () => void;
  /** On cursor position change */
  onCursorChange?: (line: number, col: number) => void;
  /** On scroll */
  onScroll?: (scrollTop: number) => void;
}

// ===================== SYNTAX HIGHLIGHTING =====================

interface Token {
  text: string;
  type: 'keyword' | 'from' | 'system' | 'template' | 'parameter' | 'key' | 'value' | 'comment' | 'string' | 'number' | 'operator' | 'punctuation' | 'plain' | 'section';
}

function tokenizeIniLine(line: string): Token[] {
  const trimmed = line.trim();
  const tokens: Token[] = [];

  // Empty line
  if (!trimmed) {
    tokens.push({ text: line, type: 'plain' });
    return tokens;
  }

  // Comments
  if (trimmed.startsWith('#') || trimmed.startsWith(';')) {
    tokens.push({ text: line, type: 'comment' });
    return tokens;
  }

  // Multi-line delimiter
  if (trimmed === '"""') {
    tokens.push({ text: line, type: 'string' });
    return tokens;
  }

  // FROM directive
  if (trimmed.toUpperCase().startsWith('FROM ')) {
    const idx = line.toUpperCase().indexOf('FROM ');
    tokens.push({ text: line.substring(0, idx), type: 'plain' });
    tokens.push({ text: 'FROM', type: 'from' });
    tokens.push({ text: ' ', type: 'plain' });
    const rest = line.substring(idx + 5);
    tokens.push({ text: rest, type: 'string' });
    return tokens;
  }

  // SYSTEM directive
  if (trimmed.toUpperCase().startsWith('SYSTEM ')) {
    const idx = line.toUpperCase().indexOf('SYSTEM ');
    tokens.push({ text: line.substring(0, idx), type: 'plain' });
    tokens.push({ text: 'SYSTEM', type: 'system' });
    tokens.push({ text: ' ', type: 'plain' });
    const rest = line.substring(idx + 7);
    if (rest.startsWith('"""')) {
      tokens.push({ text: '"""', type: 'punctuation' });
      tokens.push({ text: rest.substring(3), type: 'string' });
    } else {
      tokens.push({ text: rest, type: 'string' });
    }
    return tokens;
  }

  // TEMPLATE directive
  if (trimmed.toUpperCase().startsWith('TEMPLATE ')) {
    const idx = line.toUpperCase().indexOf('TEMPLATE ');
    tokens.push({ text: line.substring(0, idx), type: 'plain' });
    tokens.push({ text: 'TEMPLATE', type: 'template' });
    tokens.push({ text: ' ', type: 'plain' });
    const rest = line.substring(idx + 9);
    if (rest.startsWith('"""')) {
      tokens.push({ text: '"""', type: 'punctuation' });
      tokens.push({ text: rest.substring(3), type: 'string' });
    } else {
      tokens.push({ text: rest, type: 'string' });
    }
    return tokens;
  }

  // PARAMETER directive
  if (trimmed.toUpperCase().startsWith('PARAMETER ')) {
    const idx = line.toUpperCase().indexOf('PARAMETER ');
    tokens.push({ text: line.substring(0, idx), type: 'plain' });
    tokens.push({ text: 'PARAMETER', type: 'parameter' });
    const rest = line.substring(idx + 9);
    const parts = rest.trim().split(/(\s+)/);
    if (parts.length >= 1) {
      tokens.push({ text: ' ', type: 'plain' });
      tokens.push({ text: parts[0], type: 'key' });
      if (parts.length > 1) {
        tokens.push({ text: parts[1], type: 'plain' });
        const valStr = parts.slice(2).join('');
        if (!isNaN(Number(valStr)) && valStr.length > 0) {
          tokens.push({ text: valStr, type: 'number' });
        } else {
          tokens.push({ text: valStr, type: 'value' });
        }
      }
    }
    return tokens;
  }

  // Section header [Section]
  if (trimmed.startsWith('[') && trimmed.endsWith(']')) {
    tokens.push({ text: line, type: 'section' });
    return tokens;
  }

  // Key=Value pairs
  if (trimmed.includes('=')) {
    const eqIndex = line.indexOf('=');
    const key = line.substring(0, eqIndex);
    const eq = '=';
    const val = line.substring(eqIndex + 1);
    tokens.push({ text: key, type: 'key' });
    tokens.push({ text: eq, type: 'operator' });
    const trimVal = val.trim();
    if (!isNaN(Number(trimVal)) && trimVal.length > 0) {
      tokens.push({ text: val, type: 'number' });
    } else {
      tokens.push({ text: val, type: 'value' });
    }
    return tokens;
  }

  // Plain text (could be multiline system/template content)
  tokens.push({ text: line, type: 'string' });
  return tokens;
}

function getTokenColor(type: Token['type']): string {
  const colorMap: Record<string, string> = {
    keyword: 'var(--ini-keyword)',
    from: 'var(--ini-from)',
    system: 'var(--ini-system)',
    template: 'var(--ini-template)',
    parameter: 'var(--ini-keyword)',
    key: 'var(--ini-key)',
    value: 'var(--ini-value)',
    comment: 'var(--ini-comment)',
    string: 'var(--ini-string)',
    number: 'var(--ini-number)',
    operator: 'var(--text-tertiary)',
    punctuation: 'var(--text-tertiary)',
    plain: 'var(--text-editor)',
    section: 'var(--ini-keyword)',
  };
  return colorMap[type] || 'var(--text-editor)';
}

function getTokenFontWeight(type: Token['type']): number {
  const boldTypes = ['from', 'system', 'template', 'parameter', 'keyword', 'section'];
  return boldTypes.includes(type) ? 700 : 400;
}

// ===================== HIGHLIGHTED CONTENT =====================

function HighlightedContent({
  content,
  language,
  fontSize,
  lineHeight,
}: {
  content: string;
  language: 'ini' | 'plain';
  fontSize: number;
  lineHeight: number;
}) {
  const lines = content.split('\n');

  return (
    <div
      aria-hidden="true"
      style={{
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        pointerEvents: 'none',
        fontFamily: "'JetBrains Mono', 'Fira Code', 'Consolas', 'Monaco', 'Courier New', monospace",
        fontSize,
        lineHeight: `${lineHeight}px`,
        whiteSpace: 'pre',
        wordWrap: 'normal',
        overflowWrap: 'normal',
        padding: 0,
        margin: 0,
      }}
    >
      {lines.map((line, i) => {
        const tokens = language === 'ini' ? tokenizeIniLine(line) : [{ text: line, type: 'plain' as const }];
        return (
          <div key={i} style={{ height: lineHeight, display: 'flex', alignItems: 'center' }}>
            {tokens.map((token, j) => (
              <span
                key={j}
                style={{
                  color: getTokenColor(token.type),
                  fontWeight: getTokenFontWeight(token.type),
                  fontStyle: token.type === 'comment' ? 'italic' : 'normal',
                }}
              >
                {token.text}
              </span>
            ))}
            {line === '' && <span>&nbsp;</span>}
          </div>
        );
      })}
    </div>
  );
}

// ===================== CODE EDITOR COMPONENT =====================

export function CodeEditor({
  value,
  onChange,
  readOnly = false,
  fontSize = 13,
  language = 'ini',
  placeholder = '',
  showLineNumbers = true,
  highlightActiveLine = true,
  highlightLine = null,
  tabSize = 2,
  wordWrap = false,
  maxHeight,
  minHeight = '200px',
  className = '',
  onFocus,
  onBlur,
  onCursorChange,
  onScroll,
}: CodeEditorProps) {
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const highlightRef = useRef<HTMLDivElement>(null);
  const gutterRef = useRef<HTMLDivElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  const [isFocused, setIsFocused] = useState(false);
  const [cursorLine, setCursorLine] = useState(1);
  const [cursorCol, setCursorCol] = useState(1);
  const [scrollTop, setScrollTop] = useState(0);
  const [scrollLeft, setScrollLeft] = useState(0);

  const lineHeight = Math.round(fontSize * 1.65);
  const lines = useMemo(() => value.split('\n'), [value]);
  const lineCount = lines.length;
  const gutterWidth = Math.max(40, String(lineCount).length * 10 + 24);

  // Sync scroll between textarea and highlight overlay & gutter
  const handleScroll = useCallback(() => {
    const ta = textareaRef.current;
    if (!ta) return;
    const st = ta.scrollTop;
    const sl = ta.scrollLeft;
    setScrollTop(st);
    setScrollLeft(sl);
    if (highlightRef.current) {
      highlightRef.current.scrollTop = st;
      highlightRef.current.scrollLeft = sl;
    }
    if (gutterRef.current) {
      gutterRef.current.scrollTop = st;
    }
    onScroll?.(st);
  }, [onScroll]);

  // Cursor tracking
  const updateCursor = useCallback(() => {
    const ta = textareaRef.current;
    if (!ta) return;
    const pos = ta.selectionStart;
    const textBefore = value.substring(0, pos);
    const linesBefore = textBefore.split('\n');
    const line = linesBefore.length;
    const col = linesBefore[linesBefore.length - 1].length + 1;
    setCursorLine(line);
    setCursorCol(col);
    onCursorChange?.(line, col);
  }, [value, onCursorChange]);

  // Handle text change
  const handleChange = useCallback((e: React.ChangeEvent<HTMLTextAreaElement>) => {
    if (readOnly) return;
    onChange?.(e.target.value);
  }, [readOnly, onChange]);

  // Handle keydown for tab support
  const handleKeyDown = useCallback((e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (readOnly) return;

    // Tab key
    if (e.key === 'Tab') {
      e.preventDefault();
      const ta = textareaRef.current;
      if (!ta) return;
      const start = ta.selectionStart;
      const end = ta.selectionEnd;

      if (e.shiftKey) {
        // Outdent: remove leading spaces from selected lines
        const beforeStart = value.substring(0, start);
        const lineStart = beforeStart.lastIndexOf('\n') + 1;
        const selectedText = value.substring(lineStart, end);
        const selectedLines = selectedText.split('\n');
        const spaces = ' '.repeat(tabSize);
        const newLines = selectedLines.map(line => {
          if (line.startsWith(spaces)) return line.substring(tabSize);
          if (line.startsWith('\t')) return line.substring(1);
          return line.replace(/^ +/, (m) => m.substring(0, Math.max(0, m.length - tabSize)));
        });
        const newText = newLines.join('\n');
        const diff = selectedText.length - newText.length;
        const newValue = value.substring(0, lineStart) + newText + value.substring(end);
        onChange?.(newValue);
        requestAnimationFrame(() => {
          ta.selectionStart = Math.max(lineStart, start - (selectedLines[0].length - newLines[0].length));
          ta.selectionEnd = end - diff;
        });
      } else if (start !== end) {
        // Indent selected lines
        const beforeStart = value.substring(0, start);
        const lineStart = beforeStart.lastIndexOf('\n') + 1;
        const selectedText = value.substring(lineStart, end);
        const spaces = ' '.repeat(tabSize);
        const newText = selectedText.split('\n').map(line => spaces + line).join('\n');
        const diff = newText.length - selectedText.length;
        const newValue = value.substring(0, lineStart) + newText + value.substring(end);
        onChange?.(newValue);
        requestAnimationFrame(() => {
          ta.selectionStart = start + tabSize;
          ta.selectionEnd = end + diff;
        });
      } else {
        // Insert spaces at cursor
        const spaces = ' '.repeat(tabSize);
        const newValue = value.substring(0, start) + spaces + value.substring(end);
        onChange?.(newValue);
        requestAnimationFrame(() => {
          ta.selectionStart = ta.selectionEnd = start + tabSize;
        });
      }
    }

    // Enter key - auto indent
    if (e.key === 'Enter') {
      const ta = textareaRef.current;
      if (!ta) return;
      const start = ta.selectionStart;
      const beforeCursor = value.substring(0, start);
      const currentLineStart = beforeCursor.lastIndexOf('\n') + 1;
      const currentLine = beforeCursor.substring(currentLineStart);
      const indent = currentLine.match(/^(\s*)/)?.[1] || '';

      if (indent) {
        e.preventDefault();
        const newValue = value.substring(0, start) + '\n' + indent + value.substring(ta.selectionEnd);
        onChange?.(newValue);
        requestAnimationFrame(() => {
          const newPos = start + 1 + indent.length;
          ta.selectionStart = ta.selectionEnd = newPos;
        });
      }
    }

    // Ctrl+A or Cmd+A - select all (default behavior is fine)
    // Ctrl+D or Cmd+D - duplicate line
    if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
      e.preventDefault();
      const ta = textareaRef.current;
      if (!ta) return;
      const pos = ta.selectionStart;
      const beforePos = value.substring(0, pos);
      const lineStart = beforePos.lastIndexOf('\n') + 1;
      const afterPos = value.substring(pos);
      const lineEndOffset = afterPos.indexOf('\n');
      const lineEnd = lineEndOffset === -1 ? value.length : pos + lineEndOffset;
      const currentLine = value.substring(lineStart, lineEnd);
      const newValue = value.substring(0, lineEnd) + '\n' + currentLine + value.substring(lineEnd);
      onChange?.(newValue);
      requestAnimationFrame(() => {
        ta.selectionStart = ta.selectionEnd = pos + currentLine.length + 1;
      });
    }
  }, [readOnly, value, onChange, tabSize]);

  // Handle focus
  const handleFocus = useCallback(() => {
    setIsFocused(true);
    onFocus?.();
  }, [onFocus]);

  const handleBlur = useCallback(() => {
    setIsFocused(false);
    onBlur?.();
  }, [onBlur]);

  // Scroll highlighted line into view
  useEffect(() => {
    if (highlightLine !== null && highlightLine > 0 && containerRef.current) {
      const targetScroll = (highlightLine - 1) * lineHeight - containerRef.current.clientHeight / 2 + lineHeight;
      if (textareaRef.current) {
        textareaRef.current.scrollTop = Math.max(0, targetScroll);
      }
    }
  }, [highlightLine, lineHeight]);

  return (
    <div
      className={className}
      style={{
        display: 'flex',
        flexDirection: 'column',
        height: '100%',
        minHeight,
        maxHeight: maxHeight || '100%',
        background: 'var(--bg-editor)',
        borderRadius: 'var(--border-radius)',
        border: `1.5px solid ${isFocused ? 'var(--border-focus)' : 'var(--border-color)'}`,
        overflow: 'hidden',
        transition: 'border-color 0.2s ease',
        position: 'relative',
      }}
    >
      {/* Editor body */}
      <div
        ref={containerRef}
        style={{
          flex: 1,
          display: 'flex',
          overflow: 'hidden',
          position: 'relative',
        }}
      >
        {/* Gutter (line numbers) */}
        {showLineNumbers && (
          <div
            ref={gutterRef}
            style={{
              width: gutterWidth,
              minWidth: gutterWidth,
              flexShrink: 0,
              background: 'var(--bg-editor-gutter)',
              borderRight: '1px solid var(--border-color)',
              overflow: 'hidden',
              userSelect: 'none',
              paddingTop: 10,
              paddingBottom: 10,
            }}
          >
            <div style={{ transform: `translateY(${-scrollTop}px)` }}>
              {Array.from({ length: lineCount }, (_, i) => {
                const lineNum = i + 1;
                const isActive = highlightActiveLine && cursorLine === lineNum && isFocused;
                const isHighlighted = highlightLine === lineNum;
                return (
                  <div
                    key={i}
                    style={{
                      height: lineHeight,
                      lineHeight: `${lineHeight}px`,
                      fontSize: fontSize - 1,
                      textAlign: 'right',
                      paddingRight: 12,
                      paddingLeft: 8,
                      fontFamily: "'JetBrains Mono', 'Fira Code', 'Consolas', 'Monaco', monospace",
                      color: isActive || isHighlighted
                        ? 'var(--text-editor-line-number-active)'
                        : 'var(--text-editor-line-number)',
                      background: isHighlighted
                        ? 'var(--bg-current-line)'
                        : isActive
                          ? 'var(--bg-editor-active-line)'
                          : 'transparent',
                      fontWeight: isActive || isHighlighted ? 600 : 400,
                      transition: 'all 0.1s ease',
                    }}
                  >
                    {lineNum}
                  </div>
                );
              })}
            </div>
          </div>
        )}

        {/* Code area */}
        <div style={{ flex: 1, position: 'relative', overflow: 'hidden' }}>
          {/* Active line highlight */}
          {highlightActiveLine && isFocused && (
            <div
              style={{
                position: 'absolute',
                top: (cursorLine - 1) * lineHeight + 10 - scrollTop,
                left: 0,
                right: 0,
                height: lineHeight,
                background: 'var(--bg-editor-active-line)',
                pointerEvents: 'none',
                zIndex: 0,
                transition: 'top 0.05s ease',
              }}
            />
          )}

          {/* Highlighted line */}
          {highlightLine !== null && highlightLine > 0 && (
            <div
              style={{
                position: 'absolute',
                top: (highlightLine - 1) * lineHeight + 10 - scrollTop,
                left: 0,
                right: 0,
                height: lineHeight,
                background: 'var(--bg-current-line)',
                pointerEvents: 'none',
                zIndex: 0,
                borderLeft: '3px solid var(--primary-color)',
              }}
            />
          )}

          {/* Syntax highlighted overlay */}
          <div
            ref={highlightRef}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              overflow: 'hidden',
              padding: '10px 12px',
              pointerEvents: 'none',
              zIndex: 1,
            }}
          >
            <div style={{ transform: `translate(${-scrollLeft}px, ${-scrollTop}px)` }}>
              <HighlightedContent
                content={value}
                language={language}
                fontSize={fontSize}
                lineHeight={lineHeight}
              />
            </div>
          </div>

          {/* Textarea (invisible but captures input) */}
          <textarea
            ref={textareaRef}
            className="code-editor-textarea"
            value={value}
            onChange={handleChange}
            onKeyDown={handleKeyDown}
            onScroll={handleScroll}
            onClick={updateCursor}
            onKeyUp={updateCursor}
            onFocus={handleFocus}
            onBlur={handleBlur}
            readOnly={readOnly}
            placeholder={placeholder}
            spellCheck={false}
            autoCapitalize="off"
            autoComplete="off"
            autoCorrect="off"
            data-gramm="false"
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: '100%',
              padding: '10px 12px',
              margin: 0,
              border: 'none',
              outline: 'none',
              resize: 'none',
              background: 'transparent',
              color: 'transparent',
              fontFamily: "'JetBrains Mono', 'Fira Code', 'Consolas', 'Monaco', 'Courier New', monospace",
              fontSize,
              lineHeight: `${lineHeight}px`,
              whiteSpace: wordWrap ? 'pre-wrap' : 'pre',
              wordWrap: wordWrap ? 'break-word' : 'normal',
              overflowWrap: wordWrap ? 'break-word' : 'normal',
              tabSize,
              zIndex: 2,
              WebkitTextFillColor: 'transparent',
            }}
          />
        </div>
      </div>

      {/* Status bar */}
      <div
        style={{
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'space-between',
          padding: '4px 12px',
          background: 'var(--bg-editor-gutter)',
          borderTop: '1px solid var(--border-color)',
          fontSize: 11,
          fontFamily: "'JetBrains Mono', 'Fira Code', 'Consolas', monospace",
          color: 'var(--text-editor-line-number)',
          userSelect: 'none',
          flexShrink: 0,
        }}
      >
        <div style={{ display: 'flex', gap: 16 }}>
          <span>行 {cursorLine}, 列 {cursorCol}</span>
          <span>{lineCount} 行</span>
          <span>{value.length} 字符</span>
        </div>
        <div style={{ display: 'flex', gap: 16 }}>
          <span>{language.toUpperCase()}</span>
          {readOnly && <span style={{ color: 'var(--ini-value)' }}>只读</span>}
          <span>UTF-8</span>
          <span>空格: {tabSize}</span>
        </div>
      </div>
    </div>
  );
}

export default CodeEditor;
