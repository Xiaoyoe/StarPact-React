## 一、核心组件架构
### 1. LineNumberArea类（行号显示区域）
```
class LineNumberArea(QWidget):
    """行号显示区域"""
    def __init__(self, editor):
        super().__init__(editor)
        self.codeEditor = editor
        self.setFixedWidth(40)  # 行号区域宽度
```
功能 ：

- 继承自QWidget，作为独立的行号显示组件
- 与编辑器关联，接收编辑器引用
- 固定宽度40px（后续会动态调整）
### 2. CodeEditor类（带行号的编辑器）
```
class CodeEditor(QPlainTextEdit):
    """带行号的代码编辑器"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.lineNumberArea = LineNumberArea(self)  # 创建行号区域
```
功能 ：

- 继承自QPlainTextEdit，提供文本编辑功能
- 包含LineNumberArea实例作为子组件
- 管理行号显示和文本编辑的协调
## 二、自动更新机制（信号槽机制）
### 3. 信号连接（核心机制）
```
# 连接信号
self.blockCountChanged.connect(self.updateLineNumberAreaWidth)
self.updateRequest.connect(self.updateLineNumberArea)
self.cursorPositionChanged.connect(self.highlightCurrentLine)
```
三个关键信号 ：
 3.1 blockCountChanged信号
- 触发时机 ：当文本块（行）数量发生变化时
- 连接方法 ： updateLineNumberAreaWidth
- 功能 ：自动重新计算行号区域宽度 3.2 updateRequest信号
- 触发时机 ：当编辑器需要更新显示时（滚动、编辑等）
- 连接方法 ： updateLineNumberArea
- 功能 ：自动更新行号区域的显示内容 3.3 cursorPositionChanged信号
- 触发时机 ：当光标位置发生变化时
- 连接方法 ： highlightCurrentLine
- 功能 ：自动高亮当前行
## 三、行号宽度自动调整
### 4. lineNumberAreaWidth方法
```
def lineNumberAreaWidth(self):
    """计算行号区域宽度，确保足够宽，不挡住内容"""
    digits = 1
    max_value = max(1, self.blockCount())
    while max_value >= 10:
        max_value /= 10
        digits += 1
    
    # 增加行号区域宽度，确保行号和内容之间有足够间距
    # 额外增加10px空间，确保内容不会被行号挡住
    space = 15 + self.fontMetrics().horizontalAdvance('9') * digits
    return max(50, space)  # 确保行号区域至少有50px宽
```
计算逻辑 ：

1. 计算行数位数 ：根据总行数计算需要的位数
   - 例如：100行需要3位，1000行需要4位
2. 计算宽度 ： 15px + 字体宽度 * 位数
   - 15px：基础间距
   - 字体宽度 * 位数 ：行号数字所需宽度
3. 最小宽度 ：确保至少50px宽，避免行号被截断
### 5. updateLineNumberAreaWidth方法
```
def updateLineNumberAreaWidth(self, _):
    """更新行号区域宽度"""
    self.setViewportMargins(self.lineNumberAreaWidth(), 0, 0, 0)
```
功能 ：

- 调用 lineNumberAreaWidth() 计算新的宽度
- 使用 setViewportMargins() 设置编辑器的左边距
- 左边距等于行号区域宽度，为行号预留空间
## 四、行号区域更新
### 6. updateLineNumberArea方法
```
def updateLineNumberArea(self, rect, dy):
    """更新行号区域"""
    if dy:
        self.lineNumberArea.scroll(0, dy)  # 滚动更新
    else:
        self.lineNumberArea.update(0, rect.y(), self.lineNumberArea.width(), rect.
        height())  # 局部更新
    
    if rect.contains(self.viewport().rect()):
        self.updateLineNumberAreaWidth(0)  # 如果需要，更新宽度
```
更新策略 ：

1. 滚动更新 ：如果 dy 不为0（垂直滚动），同步滚动行号区域
2. 局部更新 ：如果 dy 为0（编辑更新），只更新可见区域
3. 宽度检查 ：检查是否需要更新行号区域宽度
## 五、行号绘制机制
### 7. lineNumberAreaPaintEvent方法
```
def lineNumberAreaPaintEvent(self, event):
    """绘制行号区域，背景透明"""
    painter = QPainter(self.lineNumberArea)
    # 背景设为透明
    painter.fillRect(event.rect(), QColor(255, 255, 255, 0))
    
    block = self.firstVisibleBlock()  # 获取第一个可见的文本块
    blockNumber = block.blockNumber()  # 获取块号（行号）
    top = self.blockBoundingGeometry(block).translated(self.contentOffset()).top()
    bottom = top + self.blockBoundingRect(block).height()
    
    # 设置行号字体和颜色
    font = painter.font()
    font.setBold(True)
    painter.setFont(font)
    painter.setPen(QColor(100, 100, 100))  # 行号颜色稍深，增加可读性
    
    while block.isValid() and top <= event.rect().bottom():
        if block.isVisible() and bottom >= event.rect().top():
            number = str(blockNumber + 1)
            painter.drawText(
                5,  # 左侧边距
                int(top), 
                self.lineNumberArea.width() - 10,  # 右侧边距
                self.fontMetrics().height(), 
                Qt.AlignmentFlag.AlignRight, 
                number
            )
        
        block = block.next()
        top = bottom
        bottom = top + self.blockBoundingRect(block).height()
        blockNumber += 1
```
绘制逻辑 ：

1. 获取可见块 ：从第一个可见的文本块开始
2. 计算位置 ：计算每个块（行）的垂直位置
3. 绘制行号 ：只绘制可见区域的行号
4. 样式设置 ：加粗字体，深灰色文字，右对齐
5. 背景透明 ：背景设为透明，不遮挡内容
## 六、窗口大小调整
### 8. resizeEvent方法
```
def resizeEvent(self, event):
    """调整大小事件"""
    super().resizeEvent(event)
    cr = self.contentsRect()
    self.lineNumberArea.setGeometry(QRect(cr.left(), cr.top(), self.
    lineNumberAreaWidth(), cr.height()))
```
功能 ：

- 窗口大小变化时自动调用
- 重新设置行号区域的位置和大小
- 确保行号区域始终在编辑器左侧
## 七、自动更新流程总结
### 完整的自动更新流程：
1. 文本内容变化 → 触发 blockCountChanged 信号
   
   - 调用 updateLineNumberAreaWidth()
   - 重新计算行号区域宽度
   - 更新编辑器的左边距
2. 编辑器滚动/编辑 → 触发 updateRequest 信号
   
   - 调用 updateLineNumberArea()
   - 同步滚动行号区域或局部更新
   - 检查是否需要更新宽度
3. 光标移动 → 触发 cursorPositionChanged 信号
   
   - 调用 highlightCurrentLine()
   - 高亮显示当前行
4. 窗口大小变化 → 触发 resizeEvent 事件
   
   - 重新设置行号区域的位置和大小
   - 确保行号区域正确显示
## 八、关键技术点
### 1. 信号槽机制
- Qt的核心特性，实现组件间通信
- 自动响应各种事件，无需手动调用
### 2. 只绘制可见区域
- 性能优化，避免绘制不可见的行号
- 根据滚动位置动态更新
### 3. 动态宽度计算
- 根据行数自动调整行号区域宽度
- 确保行号不被截断，同时不浪费空间
### 4. 透明背景
- 行号区域背景透明，不遮挡内容
- 只绘制行号数字，不影响文本显示
### 5. 同步滚动
- 行号区域与文本内容同步滚动
- 保持行号与文本行的对应关系
## 九、优势特点
1. 完全自动化 ：无需手动调用更新方法，信号槽机制自动处理
2. 性能优化 ：只绘制可见区域，避免不必要的重绘
3. 自适应宽度 ：根据行数自动调整宽度，避免截断
4. 实时同步 ：与文本内容实时同步，始终保持准确
5. 用户体验好 ：当前行高亮，便于定位和编辑
这种实现方式充分利用了Qt的信号槽机制，实现了高效、自动、准确的行号显示功能。